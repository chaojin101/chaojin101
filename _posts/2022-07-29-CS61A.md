---
title: CS61A Note
categories: ["CS61A"]
tags: ["CS61A"]
math: true
pin: true
---

Official Website 2020: <https://inst.eecs.berkeley.edu/~cs61a/su20/>

### lab03 Q4: Repeated, repeated
In Homework 2 you encountered the **repeated** function, which takes arguments **f** and **n** and returns a function equivalent to the nth repeated application of **f**. This time, we want to write **repeated** recursively. You'll want to use **compose1**, given below for your convenience:
```python
def compose1(f, g):
    """"Return a function h, such that h(x) = f(g(x))."""
    def h(x):
        return f(g(x))
    return h
```
```py
def repeated(f, n):
    """Return the function that computes the nth application of func (recursively!).

    >>> add_three = repeated(lambda x: x + 1, 3)
    >>> add_three(5)
    8
    >>> square = lambda x: x ** 2
    >>> repeated(square, 2)(5) # square(square(5))
    625
    >>> repeated(square, 4)(5) # square(square(square(square(5))))
    152587890625
    >>> repeated(square, 0)(5)
    5
    >>> from construct_check import check
    >>> # ban iteration
    >>> check(HW_SOURCE_FILE, 'repeated',
    ...       ['For', 'While'])
    True
    """
    "*** YOUR CODE HERE ***"
```
Use Ok to test your code:
```sh
python3 ok -q repeated
```

In the beginning, I didn't use **compose1**, and didn't repeat the **repeated**. Here is the code:
```py
def repeated(f, n):
    def repeater(x):
        nonlocal n
        if n == 0:
            return x
        n -= 1
        x = f(x)
        return repeater(x)
    return repeater
```

After a while, I find I can use **compose1** to use one **f**, and reduce n.
```py
def repeated(f, n):
    if n == 0:
        return lambda x: x
    return compose1(repeated(f, n-1), f)
```

### hw03 Q4: Count change
Once the machines take over, the denomination of every coin will be a power of two: 1-cent, 2-cent, 4-cent, 8-cent, 16-cent, etc. There will be no limit to how much a coin can be worth.

Given a positive integer **total**, a set of coins makes change for **total** if the sum of the values of the coins is **total**. For example, the following sets make change for **7**:

- 7 1-cent coins
- 5 1-cent, 1 2-cent coins
- 3 1-cent, 2 2-cent coins
- 3 1-cent, 1 4-cent coins
- 1 1-cent, 3 2-cent coins
- 1 1-cent, 1 2-cent, 1 4-cent coins

Thus, there are 6 ways to make change for **7**. Write a recursive function **count_change** that takes a positive integer **total** and returns the number of ways to make change for **total** using these coins of the future.

> *Hint*: Refer the [implementation](http://composingprograms.com/pages/17-recursive-functions.html#example-partitions) of **count_partitions** for an example of how to count the ways to sum up to a total with smaller parts. If you need to keep track of more than one value across recursive calls, consider writing a helper function.

```py
def count_change(total):
    """Return the number of ways to make change for total.

    >>> count_change(7)
    6
    >>> count_change(10)
    14
    >>> count_change(20)
    60
    >>> count_change(100)
    9828
    >>> from construct_check import check
    >>> # ban iteration
    >>> check(HW_SOURCE_FILE, 'count_change', ['While', 'For'])
    True
    """
    "*** YOUR CODE HERE ***"
```
Solution:
```py
def count_change(total):
    def h(total, cent):
        if total == cent: # if total == 1, will count less changes
            return 1
        elif total < 1:
            return 0
        elif cent > total:
            return 0
        return h(total-cent, cent) + h(total, cent*2)
    return h(total, 1)
```